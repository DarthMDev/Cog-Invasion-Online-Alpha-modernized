/*
 * This file was generated by:
 * ..\..\..\Panda3D-CI\bin\interrogate -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -D_MSC_VER=1600 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -oc libccoginvasion_igate.cxx -od libccoginvasion.in -fnames -string -refcount -assert -python-native -S..\..\..\Panda3D-CI/include/parser-inc -S..\..\..\Panda3D-CI/include -S..\..\..\Panda3D-CI/python/include -module libccoginvasion -library libccoginvasion config_ccoginvasion.cxx labelScaler.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libccoginvasion
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "asyncTaskManager.h"
#include <cmath>
#include <dconfig.h>
#include "genericAsyncTask.h"
#include <iostream>
#include "labelScaler.h"
#include "nodePath.h"
#include <pandabase.h>
#include <string>

#undef _POSIX_C_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. LabelScaler
//********************************************************************
typedef LabelScaler LabelScaler_localtype;
Define_Module_Class(libccoginvasion, LabelScaler, LabelScaler_localtype, LabelScaler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LabelScaler = &Dtool_LabelScaler;
static void Dtool_PyModuleClassInit_LabelScaler(PyObject *module);
bool Dtool_ConstCoerce_LabelScaler(PyObject *args, LabelScaler const *&coerced, bool &manage);
bool Dtool_Coerce_LabelScaler(PyObject *args, LabelScaler *&coerced, bool &manage);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// AsyncTaskManager
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AsyncTaskManager;
inline static bool Dtool_ConstCoerce_AsyncTaskManager(PyObject *args, CPT(AsyncTaskManager) &coerced) {
  nassertr(Dtool_Ptr_AsyncTaskManager != NULL, false);
  nassertr(Dtool_Ptr_AsyncTaskManager->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(AsyncTaskManager) &))Dtool_Ptr_AsyncTaskManager->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_AsyncTaskManager(PyObject *args, PT(AsyncTaskManager) &coerced) {
  nassertr(Dtool_Ptr_AsyncTaskManager != NULL, false);
  nassertr(Dtool_Ptr_AsyncTaskManager->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(AsyncTaskManager) &))Dtool_Ptr_AsyncTaskManager->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTaskManager;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskManager = &Dtool_AsyncTaskManager;
extern bool Dtool_ConstCoerce_AsyncTaskManager(PyObject *args, CPT(AsyncTaskManager) &coerced);
extern bool Dtool_Coerce_AsyncTaskManager(PyObject *args, PT(AsyncTaskManager) &coerced);
#endif

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. LabelScaler
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void LabelScaler::resize(void)
 *******************************************************************/
static PyObject *Dtool_LabelScaler_resize_4(PyObject *self, PyObject *) {
  LabelScaler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LabelScaler, (void **)&local_this, "LabelScaler.resize")) {
    return NULL;
  }
  // 1-void LabelScaler::resize(void)
  local_this->resize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LabelScaler_resize_4_comment =
  "C++ Interface:\n"
  "resize(const LabelScaler self)\n";
#else
static const char *Dtool_LabelScaler_resize_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float LabelScaler::get_scaling_factor(void)
 *******************************************************************/
static PyObject *Dtool_LabelScaler_get_scaling_factor_5(PyObject *self, PyObject *) {
  LabelScaler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LabelScaler, (void **)&local_this, "LabelScaler.get_scaling_factor")) {
    return NULL;
  }
  // 1-float LabelScaler::get_scaling_factor(void)
  float return_value = local_this->get_scaling_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LabelScaler_get_scaling_factor_5_comment =
  "C++ Interface:\n"
  "get_scaling_factor(const LabelScaler self)\n";
#else
static const char *Dtool_LabelScaler_get_scaling_factor_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath &LabelScaler::get_np(void)
 *******************************************************************/
static PyObject *Dtool_LabelScaler_get_np_6(PyObject *self, PyObject *) {
  LabelScaler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LabelScaler, (void **)&local_this, "LabelScaler.get_np")) {
    return NULL;
  }
  // 1-NodePath &LabelScaler::get_np(void)
  NodePath *return_value = &(local_this->get_np());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LabelScaler_get_np_6_comment =
  "C++ Interface:\n"
  "get_np(const LabelScaler self)\n";
#else
static const char *Dtool_LabelScaler_get_np_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath &LabelScaler::get_cam(void)
 *******************************************************************/
static PyObject *Dtool_LabelScaler_get_cam_7(PyObject *self, PyObject *) {
  LabelScaler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LabelScaler, (void **)&local_this, "LabelScaler.get_cam")) {
    return NULL;
  }
  // 1-NodePath &LabelScaler::get_cam(void)
  NodePath *return_value = &(local_this->get_cam());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LabelScaler_get_cam_7_comment =
  "C++ Interface:\n"
  "get_cam(const LabelScaler self)\n";
#else
static const char *Dtool_LabelScaler_get_cam_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskManager *LabelScaler::get_task_mgr(void)
 *******************************************************************/
static PyObject *Dtool_LabelScaler_get_task_mgr_8(PyObject *self, PyObject *) {
  LabelScaler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LabelScaler, (void **)&local_this, "LabelScaler.get_task_mgr")) {
    return NULL;
  }
  // 1-AsyncTaskManager *LabelScaler::get_task_mgr(void)
  AsyncTaskManager *return_value = local_this->get_task_mgr();
  if (return_value != (AsyncTaskManager *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AsyncTaskManager *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LabelScaler_get_task_mgr_8_comment =
  "C++ Interface:\n"
  "get_task_mgr(const LabelScaler self)\n";
#else
static const char *Dtool_LabelScaler_get_task_mgr_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LabelScaler::LabelScaler(NodePath &node, NodePath &camera)
 *******************************************************************/
static int Dtool_Init_LabelScaler(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-LabelScaler::LabelScaler(NodePath &node, NodePath &camera)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"node", "camera", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LabelScaler", (char **)keyword_list, &param0, &param1)) {
    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "LabelScaler.LabelScaler", false, true);
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "LabelScaler.LabelScaler", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      LabelScaler *return_value = new LabelScaler(*param0_this, *param1_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LabelScaler, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LabelScaler(NodePath node, NodePath camera)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LabelScaler(PyObject *args, LabelScaler const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LabelScaler, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LabelScaler::LabelScaler(NodePath &node, NodePath &camera)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "LabelScaler", 2, 2, &param0, &param1)) {
        NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "LabelScaler.LabelScaler", false, false);
        NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "LabelScaler.LabelScaler", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          LabelScaler *return_value = new LabelScaler(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LabelScaler(PyObject *args, LabelScaler *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LabelScaler, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LabelScaler::LabelScaler(NodePath &node, NodePath &camera)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "LabelScaler", 2, 2, &param0, &param1)) {
        NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "LabelScaler.LabelScaler", false, false);
        NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "LabelScaler.LabelScaler", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          LabelScaler *return_value = new LabelScaler(*param0_this, *param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LabelScaler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LabelScaler) {
    printf("LabelScaler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LabelScaler *local_this = (LabelScaler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LabelScaler) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LabelScaler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LabelScaler) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. LabelScaler | LabelScaler
//********************************************************************
static PyMethodDef Dtool_Methods_LabelScaler[] = {
  {"resize", &Dtool_LabelScaler_resize_4, METH_NOARGS, (const char *)Dtool_LabelScaler_resize_4_comment},
  {"get_scaling_factor", &Dtool_LabelScaler_get_scaling_factor_5, METH_NOARGS, (const char *)Dtool_LabelScaler_get_scaling_factor_5_comment},
  {"getScalingFactor", &Dtool_LabelScaler_get_scaling_factor_5, METH_NOARGS, (const char *)Dtool_LabelScaler_get_scaling_factor_5_comment},
  {"get_np", &Dtool_LabelScaler_get_np_6, METH_NOARGS, (const char *)Dtool_LabelScaler_get_np_6_comment},
  {"getNp", &Dtool_LabelScaler_get_np_6, METH_NOARGS, (const char *)Dtool_LabelScaler_get_np_6_comment},
  {"get_cam", &Dtool_LabelScaler_get_cam_7, METH_NOARGS, (const char *)Dtool_LabelScaler_get_cam_7_comment},
  {"getCam", &Dtool_LabelScaler_get_cam_7, METH_NOARGS, (const char *)Dtool_LabelScaler_get_cam_7_comment},
  {"get_task_mgr", &Dtool_LabelScaler_get_task_mgr_8, METH_NOARGS, (const char *)Dtool_LabelScaler_get_task_mgr_8_comment},
  {"getTaskMgr", &Dtool_LabelScaler_get_task_mgr_8, METH_NOARGS, (const char *)Dtool_LabelScaler_get_task_mgr_8_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LabelScaler = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_LabelScaler = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "libccoginvasion.LabelScaler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LabelScaler,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LabelScaler,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LabelScaler,
    standard_type_members,
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LabelScaler,
    PyType_GenericAlloc,
    Dtool_new_LabelScaler,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LabelScaler,
  Dtool_UpcastInterface_LabelScaler,
  Dtool_DowncastInterface_LabelScaler,
  (CoerceFunction)Dtool_ConstCoerce_LabelScaler,
  (CoerceFunction)Dtool_Coerce_LabelScaler,
};

static void Dtool_PyModuleClassInit_LabelScaler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DTOOL_SUPER_BASE != NULL);
    Dtool_Ptr_DTOOL_SUPER_BASE->_Dtool_ModuleClassInit(NULL);
    Dtool_LabelScaler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE);
    PyObject *dict = PyDict_New();
    Dtool_LabelScaler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LabelScaler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LabelScaler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LabelScaler);
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
void Dtool_libccoginvasion_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LabelScaler", Dtool_LabelScaler);
#endif
}

void Dtool_libccoginvasion_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_AsyncTaskManager = LookupRuntimeTypedClass(AsyncTaskManager::get_class_type());
#endif
}

void Dtool_libccoginvasion_BuildInstants(PyObject *module) {
  (void) module;
  // Module init upcall for LabelScaler
  // LabelScaler
  Dtool_PyModuleClassInit_LabelScaler(module);
  PyModule_AddObject(module, "LabelScaler", (PyObject *)&Dtool_LabelScaler);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libccoginvasion_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1439946891,  /* file_identifier */
  "libccoginvasion",  /* library_name */
  "I4nc",  /* library_hash_name */
  "libccoginvasion",  /* module_name */
  "libccoginvasion.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  25  /* next_index */
};

Configure(_in_configure_libccoginvasion);
ConfigureFn(_in_configure_libccoginvasion) {
  interrogate_request_module(&_in_module_def);
}

